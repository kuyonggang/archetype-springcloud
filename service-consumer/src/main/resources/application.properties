server.port=8886
server.context-path=/
spring.application.name=service-consumer1

spring.profiles.active=item1

eureka.instance.hostname=localhost
eureka.instance.server.port=8761
eureka.client.serviceUrl.defaultZone=http://${eureka.instance.hostname}:${eureka.instance.server.port}/eureka/

#开启请求压缩功能
feign.compression.request.enabled=true
#开启响应压缩功能
feign.compression.response.enabled=true
#指定压缩请求数据类型
feign.compression.request.mime-types=text/xml;application/xml;application/json
#如果传输超过该字节，就对其进行压缩
feign.compression.request.min-request-size=2048

# 开断路器
#feign.hystrix.enabled=true

#控制台彩色输出
spring.output.ansi.enabled=ALWAYS

#日志配置,该接口的日志级别
logging.level.com.archetype.springcloud.service.HelloBackgroundService=DEBUG

######### 路由配置 ################
#默认1000
#zuul.host.socket-timeout-millis=2000
#默认2000
#zuul.host.connect-timeout-millis=4000
# 取消重试机制
zuul.retryable=false
# host-header
zuul.add-host-header=false

#对所有操作请求都进行重试,默认false
#ribbon.OkToRetryOnAllOperations=false
# 请求处理超时时间，默认值5000
ribbon.ReadTimeout=3000
# 请求连接超时时间，默认值2000 ribbon的ConnectTimeout,配置的是请求服务的超时时间,除非服务找不到,或者网络原因,这个时间才会生效
ribbon.ConnectTimeout=2000
# ribbon还有MaxAutoRetries对当前实例的重试次数,MaxAutoRetriesNextServer对切换实例的重试次数, 如果ribbon的ReadTimeout超时,或者ConnectTimeout连接超时,会进行重试操作
# 由于ribbon的重试机制,通常熔断的超时时间需要配置的比ReadTimeout长,ReadTimeout比ConnectTimeout长,否则还未重试,就熔断了
# 为了确保重试机制的正常运作,理论上（以实际情况为准）建议hystrix的超时时间为:(1 + MaxAutoRetries + MaxAutoRetriesNextServer) * ReadTimeout
#ribbon.MaxAutoRetries=0
#ribbon.MaxAutoRetriesNextServer=1

# default全局有效，service id指定应用有效
# 如果hystrix.command.default.execution.timeout.enabled为true,则会有两个执行方法超时的配置,一个就是ribbon的ReadTimeout,一个就是熔断器hystrix的timeoutInMilliseconds, 此时谁的值小谁生效
# 如果hystrix.command.default.execution.timeout.enabled为false,则熔断器不进行超时熔断,而是根据ribbon的ReadTimeout抛出的异常而熔断,也就是取决于ribbon
hystrix.command.default.execution.timeout.enabled=true
# 断路器超时时间，默认1000ms
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=3000
# Hystrix线程池大小默认为10
#hystrix.threadpool.default.coreSize=10